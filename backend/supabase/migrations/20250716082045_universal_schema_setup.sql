-- =====================================================================================
-- Universal Database Migration - Verethfier Discord Bot
-- =====================================================================================
-- This migration handles both fresh installations and legacy database upgrades
-- Creates modern schema and migrates legacy data when present
-- =====================================================================================

BEGIN;

DO $$
DECLARE
    legacy_servers_count INTEGER := 0;
    legacy_users_count INTEGER := 0;
    is_legacy_migration BOOLEAN := false;
BEGIN
    RAISE NOTICE '=================================================================';
    RAISE NOTICE 'Universal Migration Starting...';
    RAISE NOTICE '=================================================================';
    
    -- Check if this is a legacy migration
    SELECT COUNT(*) INTO legacy_servers_count FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_name = 'verifier_servers';
    
    SELECT COUNT(*) INTO legacy_users_count FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_name = 'verifier_users';
    
    is_legacy_migration := (legacy_servers_count > 0 AND legacy_users_count > 0);
    
    IF is_legacy_migration THEN
        RAISE NOTICE 'Legacy tables detected - performing migration...';
    ELSE
        RAISE NOTICE 'Fresh installation - creating clean schema...';
    END IF;
    
    -- =====================================================================================
    -- STEP 1: Create update_updated_at_column function
    -- =====================================================================================
    
    RAISE NOTICE 'Creating utility functions...';
    
    CREATE OR REPLACE FUNCTION public.update_updated_at_column()
    RETURNS trigger
    LANGUAGE plpgsql
    AS $function$
    BEGIN
        NEW.updated_at = now();
        RETURN NEW;
    END;
    $function$;

    -- =====================================================================================
    -- STEP 2: Create user_wallets table (with user_name column)
    -- =====================================================================================
    
    RAISE NOTICE 'Creating user_wallets table...';
    
    CREATE TABLE IF NOT EXISTS public.user_wallets (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id text NOT NULL,
        address text NOT NULL,
        created_at timestamp with time zone DEFAULT now(),
        last_verified_at timestamp with time zone DEFAULT now(),
        user_name text,
        
        -- Constraints
        CONSTRAINT user_wallets_user_id_address_key UNIQUE (user_id, address),
        CONSTRAINT user_wallets_address_check CHECK (address ~ '^0x[a-fA-F0-9]{40}$')
    );

    -- Create indexes
    CREATE INDEX IF NOT EXISTS idx_user_wallets_user_id ON public.user_wallets USING btree (user_id);
    CREATE INDEX IF NOT EXISTS idx_user_wallets_address ON public.user_wallets USING btree (address);
    CREATE INDEX IF NOT EXISTS idx_user_wallets_last_verified ON public.user_wallets USING btree (last_verified_at);
    CREATE INDEX IF NOT EXISTS idx_user_wallets_user_name ON public.user_wallets USING btree (user_name);

    -- Enable RLS
    ALTER TABLE public.user_wallets ENABLE ROW LEVEL SECURITY;

    -- =====================================================================================
    -- STEP 3: Create verifier_rules table
    -- =====================================================================================
    
    RAISE NOTICE 'Creating verifier_rules table...';
    
    CREATE TABLE IF NOT EXISTS public.verifier_rules (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        server_id text NOT NULL,
        server_name text DEFAULT '' NOT NULL,
        channel_id text DEFAULT 'ALL' NOT NULL,
        channel_name text DEFAULT '',
        role_id text NOT NULL,
        role_name text DEFAULT '',
        slug text DEFAULT 'ALL' NOT NULL,
        attribute_key text DEFAULT 'ALL' NOT NULL,
        attribute_value text DEFAULT 'ALL' NOT NULL,
        min_items bigint DEFAULT 1 NOT NULL,
        created_at timestamp with time zone DEFAULT now(),
        
        -- Unique constraint for rule combinations
        CONSTRAINT verifier_rules_unique_rule UNIQUE (server_id, channel_id, role_id, slug, attribute_key, attribute_value, min_items)
    );

    -- Enable RLS
    ALTER TABLE public.verifier_rules ENABLE ROW LEVEL SECURITY;

    -- =====================================================================================
    -- STEP 4: Create verifier_user_roles table
    -- =====================================================================================
    
    RAISE NOTICE 'Creating verifier_user_roles table...';
    
    CREATE TABLE IF NOT EXISTS public.verifier_user_roles (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id text NOT NULL,
        server_id text NOT NULL,
        role_id text NOT NULL,
        status text DEFAULT 'active' NOT NULL,
        verified_at timestamp with time zone DEFAULT now(),
        last_checked timestamp with time zone DEFAULT now(),
        expires_at timestamp with time zone NULL,
        rule_id bigint NULL,
        verification_data jsonb DEFAULT '{}',
        user_name text,
        server_name text DEFAULT '',
        role_name text DEFAULT '',
        created_at timestamp with time zone DEFAULT now(),
        updated_at timestamp with time zone DEFAULT now(),
        
        -- Unique constraint for user-server-role combinations
        CONSTRAINT verifier_user_roles_user_id_server_id_role_id_key UNIQUE (user_id, server_id, role_id)
    );

    -- Create indexes
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_user_server ON public.verifier_user_roles USING btree (user_id, server_id);
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_rule_id ON public.verifier_user_roles USING btree (rule_id);
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_status ON public.verifier_user_roles USING btree (status);
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_last_checked ON public.verifier_user_roles USING btree (last_checked);
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_expires_at ON public.verifier_user_roles USING btree (expires_at);
    CREATE INDEX IF NOT EXISTS idx_verifier_user_roles_active_check ON public.verifier_user_roles USING btree (status, last_checked) WHERE status = 'active';

    -- Enable RLS
    ALTER TABLE public.verifier_user_roles ENABLE ROW LEVEL SECURITY;

    -- =====================================================================================
    -- STEP 5: Migrate legacy data (if present)
    -- =====================================================================================
    
    IF is_legacy_migration THEN
        RAISE NOTICE 'Migrating legacy data...';
        
        -- Migrate verifier_users -> user_wallets
        RAISE NOTICE 'Migrating legacy users to user_wallets...';
        INSERT INTO public.user_wallets (user_id, address, created_at)
        SELECT 
            user_id,
            address,
            now() as created_at
        FROM public.verifier_users
        ON CONFLICT (user_id, address) DO NOTHING;
        
        -- Migrate verifier_servers -> verifier_rules (with proper role_name extraction)
        RAISE NOTICE 'Migrating legacy servers to verifier_rules...';
        INSERT INTO public.verifier_rules (
            server_id, 
            server_name, 
            role_id, 
            role_name,
            channel_id,
            channel_name,
            slug,
            attribute_key,
            attribute_value,
            min_items,
            created_at
        )
        SELECT 
            vs.id as server_id,
            vs.name as server_name,
            vs.role_id,
            -- Extract role_name from the first user's servers JSONB that has this server
            COALESCE(
                TRIM(BOTH '"' FROM (SELECT (vu.servers->vs.id)::text 
                                   FROM public.verifier_users vu 
                                   WHERE vu.servers ? vs.id 
                                   LIMIT 1)), 
                ''
            ) as role_name,
            'ALL' as channel_id,
            'Legacy' as channel_name,
            'ALL' as slug,
            'ALL' as attribute_key,
            'ALL' as attribute_value,
            1 as min_items,
            now() as created_at
        FROM public.verifier_servers vs
        ON CONFLICT (server_id, channel_id, role_id, slug, attribute_key, attribute_value, min_items) DO NOTHING;
        
        -- Migrate user server associations -> verifier_user_roles (with proper linking and names)
        RAISE NOTICE 'Migrating legacy user-server associations to verifier_user_roles...';
        INSERT INTO public.verifier_user_roles (
            user_id,
            server_id,
            role_id,
            rule_id,
            status,
            server_name,
            role_name,
            created_at,
            verified_at
        )
        SELECT DISTINCT
            vu.user_id,
            server_key as server_id,
            vs.role_id,
            vr.id as rule_id, -- Link to the created rule
            'active' as status,
            vs.name as server_name,
            server_value as role_name, -- This comes from the JSONB value
            now() as created_at,
            now() as verified_at
        FROM public.verifier_users vu
        CROSS JOIN LATERAL jsonb_each_text(vu.servers) AS server_data(server_key, server_value)
        JOIN public.verifier_servers vs ON vs.id = server_key
        JOIN public.verifier_rules vr ON vr.server_id = vs.id AND vr.role_id = vs.role_id
        ON CONFLICT (user_id, server_id, role_id) DO NOTHING;
        
        RAISE NOTICE 'Legacy data migration completed!';
        RAISE NOTICE 'Note: Legacy tables (verifier_servers, verifier_users) remain unchanged.';
        RAISE NOTICE 'Admins can manually remove them when ready.';
        
    END IF;

    -- =====================================================================================
    -- STEP 6: Set up permissions and final configuration
    -- =====================================================================================
    
    RAISE NOTICE 'Setting up permissions...';
    
    -- Grant permissions for all tables
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.user_wallets TO anon;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.user_wallets TO authenticated;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.user_wallets TO service_role;

    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_rules TO anon;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_rules TO authenticated;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_rules TO service_role;

    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_user_roles TO anon;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_user_roles TO authenticated;
    GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE public.verifier_user_roles TO service_role;

    -- Grant sequence permissions
    GRANT ALL ON SEQUENCE public.user_wallets_id_seq TO anon;
    GRANT ALL ON SEQUENCE public.user_wallets_id_seq TO authenticated;
    GRANT ALL ON SEQUENCE public.user_wallets_id_seq TO service_role;

    GRANT ALL ON SEQUENCE public.verifier_rules_id_seq TO anon;
    GRANT ALL ON SEQUENCE public.verifier_rules_id_seq TO authenticated;
    GRANT ALL ON SEQUENCE public.verifier_rules_id_seq TO service_role;

    GRANT ALL ON SEQUENCE public.verifier_user_roles_id_seq TO anon;
    GRANT ALL ON SEQUENCE public.verifier_user_roles_id_seq TO authenticated;
    GRANT ALL ON SEQUENCE public.verifier_user_roles_id_seq TO service_role;

    -- Grant function permissions
    GRANT ALL ON FUNCTION public.update_updated_at_column() TO anon;
    GRANT ALL ON FUNCTION public.update_updated_at_column() TO authenticated;
    GRANT ALL ON FUNCTION public.update_updated_at_column() TO service_role;

    -- =====================================================================================
    -- STEP 7: Final summary
    -- =====================================================================================
    
    DECLARE
        rules_count INTEGER;
        user_roles_count INTEGER;
        wallets_count INTEGER;
    BEGIN
        SELECT COUNT(*) INTO rules_count FROM public.verifier_rules;
        SELECT COUNT(*) INTO user_roles_count FROM public.verifier_user_roles;
        SELECT COUNT(*) INTO wallets_count FROM public.user_wallets;
        
        RAISE NOTICE '=================================================================';
        RAISE NOTICE 'Universal Migration Summary:';
        RAISE NOTICE '- Migration type: %', CASE WHEN is_legacy_migration THEN 'Legacy Migration' ELSE 'Fresh Installation' END;
        RAISE NOTICE '- verifier_rules: % records', rules_count;
        RAISE NOTICE '- verifier_user_roles: % records', user_roles_count;
        RAISE NOTICE '- user_wallets: % records', wallets_count;
        
        IF is_legacy_migration THEN
            RAISE NOTICE '';
            RAISE NOTICE 'Legacy Migration Notes:';
            RAISE NOTICE '- Legacy tables preserved for manual cleanup';
            RAISE NOTICE '- All rules created with channel_id=ALL (server-wide)';
            RAISE NOTICE '- All rules created with slug/attribute_key/attribute_value=ALL (universal)';
            RAISE NOTICE '- Server names and role names properly extracted and preserved';
            RAISE NOTICE '- User roles linked to corresponding rules via rule_id';
            RAISE NOTICE '- Min items defaulted to 1 for all legacy rules';
        END IF;
        
        RAISE NOTICE '=================================================================';
    END;
    
    RAISE NOTICE 'Universal migration completed successfully!';
    
END $$;

COMMIT;
