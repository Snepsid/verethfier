import { Injectable } from '@nestjs/common';

import { createClient } from '@supabase/supabase-js';

import dotenv from 'dotenv';
dotenv.config();

const supabaseUrl = 'https://cpwubaszhjdtqlvfdlbx.supabase.co'; // 'https://gqccibjxbgyuclehqtmk.supabase.co';
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

@Injectable()
export class DbService {

  async addUpdateServer(
    serverId: string, 
    serverName: string,
    roleId: string
  ): Promise<any> {

    const { data, error } = await supabase
      .from('verifier_servers')
      .upsert({
        id: serverId,
        name: serverName,
        role_id: roleId
      });

    if (error) throw error;
    return data;
  }
  
  async getUserServers(userId: string): Promise<any> {
    const { data, error } = await supabase
      .from('verifier_users')
      .select('*')
      .eq('user_id', userId);

    if (error) throw error;
    return data[0];
  }

  async addServerToUser(
    userId: string, 
    serverId: string, 
    role: string,
    address: string
  ) {
  
    // Step 1: Retrieve the current user data with the servers JSONB object
    let { data: userData, error: fetchError } = await supabase
      .from('verifier_users')
      .select('servers')
      .eq('user_id', userId);
  
    if (fetchError) throw fetchError;
  
    const servers = userData[0]?.servers || {};
    servers[serverId] = role;
  
    const { data, error } = await supabase
      .from('verifier_users')
      .upsert({
        user_id: userId,
        address: address?.toLowerCase(),
        servers: servers
      }, {
        onConflict: 'user_id'
      });
  
    if (error) throw error;
    return data;
  }  

  async getServerRole(serverId: string): Promise<any> {
    const { data, error } = await supabase
      .from('verifier_servers')
      .select('role_id')
      .eq('id', serverId);

    if (error) throw error;
    return data[0]?.role_id;
  }

  // New methods for v2:
  async addRoleMapping(
    serverId: string,
    serverName: string,
    channelId: string,
    slug: string,
    roleId: string,
    attrKey: string,
    attrVal: string,
    minItems: number
  ): Promise<any> {
    const { data, error } = await supabase
      .from('verifier_role_mappings')
      .insert({
        server_id: serverId,
        server_name: serverName,
        channel_id: channelId,
        slug: slug,
        role_id: roleId,
        attr_key: attrKey,
        attr_val: attrVal,
        min_items: minItems
      });
    if (error) throw error;
    return data;
  }

  async getRoleMappings(serverId: string, channelId: string): Promise<any[]> {
    const { data, error } = await supabase
      .from('verifier_role_mappings')
      .select('*')
      .eq('server_id', serverId)
      .eq('channel_id', channelId);
    if (error) throw error;
    return data;
  }

  async deleteRoleMapping(ruleId: string): Promise<void> {
    const { error } = await supabase
      .from('verifier_role_mappings')
      .delete()
      .eq('id', ruleId);
    if (error) throw error;
  }

  async logUserRole(userId: string, serverId: string, roleId: string, address: string): Promise<void> {
    const { error } = await supabase
      .from('verifier_user_roles')
      .insert({
        user_id: userId,
        server_id: serverId,
        role_id: roleId,
        address: address?.toLowerCase(),
        timestamp: new Date().toISOString()
      });
    if (error) throw error;
  }

}

// create table
//   public.verifier_users (
//     id bigint generated by default as identity,
//     user_id text not null,
//     servers jsonb not null default '{}'::jsonb,
//     constraint verifier_users_pkey primary key (id, user_id)
//   ) tablespace pg_default;